# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class dotGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def graph(self, parent=None):
        with RuleContext(self, UnparserRule(name='graph', parent=parent)) as current:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.STRICT(parent=current)
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.GRAPH, self.DIGRAPH][choice0](parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    self.id_(parent=current)
            UnlexerRule(src='{', parent=current)
            self.stmt_list(parent=current)
            UnlexerRule(src='}', parent=current)
            self.EOF(parent=current)
            return current
    graph.min_depth = 1

    def stmt_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='stmt_list', parent=parent)) as current:
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.stmt(parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            UnlexerRule(src=';', parent=current)
            return current
    stmt_list.min_depth = 0

    def stmt(self, parent=None):
        with RuleContext(self, UnparserRule(name='stmt', parent=parent)) as current:
            with AlternationContext(self, [4, 4, 2, 2, 2], [1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.node_stmt(parent=current)
                elif choice0 == 1:
                    self.edge_stmt(parent=current)
                elif choice0 == 2:
                    self.attr_stmt(parent=current)
                elif choice0 == 3:
                    self.id_(parent=current)
                    UnlexerRule(src='=', parent=current)
                    self.id_(parent=current)
                elif choice0 == 4:
                    self.subgraph(parent=current)
            return current
    stmt.min_depth = 2

    def attr_stmt(self, parent=None):
        with RuleContext(self, UnparserRule(name='attr_stmt', parent=parent)) as current:
            with AlternationContext(self, [1, 1, 1], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.GRAPH, self.NODE, self.EDGE][choice0](parent=current)
            self.attr_list(parent=current)
            return current
    attr_stmt.min_depth = 1

    def attr_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='attr_list', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src='[', parent=current)
                    if self._max_depth >= 3:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.a_list(parent=current)
                    UnlexerRule(src=']', parent=current)
            return current
    attr_list.min_depth = 0

    def a_list(self, parent=None):
        with RuleContext(self, UnparserRule(name='a_list', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.id_(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            UnlexerRule(src='=', parent=current)
                            self.id_(parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 2, min=0, max=1):
                            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                                choice0 = self._model.choice(current, 0, weights0)
                                UnlexerRule(src=[';', ','][choice0], parent=current)
            return current
    a_list.min_depth = 2

    def edge_stmt(self, parent=None):
        with RuleContext(self, UnparserRule(name='edge_stmt', parent=parent)) as current:
            with AlternationContext(self, [3, 2], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.node_id, self.subgraph][choice0](parent=current)
            self.edgeRHS(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.attr_list(parent=current)
            return current
    edge_stmt.min_depth = 3

    def edgeRHS(self, parent=None):
        with RuleContext(self, UnparserRule(name='edgeRHS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.edgeop(parent=current)
                    with AlternationContext(self, [3, 2], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.node_id, self.subgraph][choice0](parent=current)
            return current
    edgeRHS.min_depth = 2

    def edgeop(self, parent=None):
        with RuleContext(self, UnparserRule(name='edgeop', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=['->', '--'][choice0], parent=current)
            return current
    edgeop.min_depth = 0

    def node_stmt(self, parent=None):
        with RuleContext(self, UnparserRule(name='node_stmt', parent=parent)) as current:
            self.node_id(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.attr_list(parent=current)
            return current
    node_stmt.min_depth = 3

    def node_id(self, parent=None):
        with RuleContext(self, UnparserRule(name='node_id', parent=parent)) as current:
            self.id_(parent=current)
            if self._max_depth >= 3:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.port(parent=current)
            return current
    node_id.min_depth = 2

    def port(self, parent=None):
        with RuleContext(self, UnparserRule(name='port', parent=parent)) as current:
            UnlexerRule(src=':', parent=current)
            self.id_(parent=current)
            if self._max_depth >= 2:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src=':', parent=current)
                    self.id_(parent=current)
            return current
    port.min_depth = 2

    def subgraph(self, parent=None):
        with RuleContext(self, UnparserRule(name='subgraph', parent=parent)) as current:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.SUBGRAPH(parent=current)
                    if self._max_depth >= 2:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.id_(parent=current)
            UnlexerRule(src='{', parent=current)
            self.stmt_list(parent=current)
            UnlexerRule(src='}', parent=current)
            return current
    subgraph.min_depth = 1

    def id_(self, parent=None):
        with RuleContext(self, UnparserRule(name='id_', parent=parent)) as current:
            with AlternationContext(self, [2, 1, 1, 2], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ID, self.STRING, self.HTML_STRING, self.NUMBER][choice0](parent=current)
            return current
    id_.min_depth = 1

    def STRICT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='STRICT', parent=parent)) as current:
            UnlexerRule(src='strict', parent=current)
            return current
    STRICT.min_depth = 0

    def GRAPH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='GRAPH', parent=parent)) as current:
            UnlexerRule(src='graph', parent=current)
            return current
    GRAPH.min_depth = 0

    def DIGRAPH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIGRAPH', parent=parent)) as current:
            UnlexerRule(src='digraph', parent=current)
            return current
    DIGRAPH.min_depth = 0

    def NODE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NODE', parent=parent)) as current:
            UnlexerRule(src='node', parent=current)
            return current
    NODE.min_depth = 0

    def EDGE(self, parent=None):
        with RuleContext(self, UnlexerRule(name='EDGE', parent=parent)) as current:
            UnlexerRule(src='edge', parent=current)
            return current
    EDGE.min_depth = 0

    def SUBGRAPH(self, parent=None):
        with RuleContext(self, UnlexerRule(name='SUBGRAPH', parent=parent)) as current:
            UnlexerRule(src='subgraph', parent=current)
            return current
    SUBGRAPH.min_depth = 0

    def NUMBER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NUMBER', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='-', parent=current)
            with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src='.', parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 1, min=1, max=inf):
                            self.DIGIT(parent=current)
                elif choice0 == 1:
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 2, min=1, max=inf):
                            self.DIGIT(parent=current)
                    if self._max_depth >= 0:
                        for _ in self._model.quantify(current, 3, min=0, max=1):
                            UnlexerRule(src='.', parent=current)
                            if self._max_depth >= 1:
                                for _ in self._model.quantify(current, 4, min=0, max=inf):
                                    self.DIGIT(parent=current)
            return current
    NUMBER.min_depth = 1

    def DIGIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIGIT', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            return current
    DIGIT.min_depth = 0

    def STRING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='STRING', parent=parent)) as current:
            UnlexerRule(src='"', parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.Char(parent=current)
            UnlexerRule(src='"', parent=current)
            return current
    STRING.min_depth = 0

    def Char(self, parent=None):
        with RuleContext(self, UnlexerRule(name='Char', parent=parent)) as current:
            with AlternationContext(self, [0, 1], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
                elif choice0 == 1:
                    self.ESC(parent=current)
            return current
    Char.min_depth = 0

    def ESC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ESC', parent=parent)) as current:
            UnlexerRule(src='\\', parent=current)
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[0]), parent=current)
            return current
    ESC.min_depth = 0

    def ID(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ID', parent=parent)) as current:
            self.LETTER(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        [self.LETTER, self.DIGIT][choice0](parent=current)
            return current
    ID.min_depth = 1

    def LETTER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LETTER', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[3]), parent=current)
            return current
    LETTER.min_depth = 0

    def HTML_STRING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HTML_STRING', parent=parent)) as current:
            UnlexerRule(src='<', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 0], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            self.TAG(parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src=self._model.charset(current, 0, self._charsets[4]), parent=current)
            UnlexerRule(src='>', parent=current)
            return current
    HTML_STRING.min_depth = 0

    def TAG(self, parent=None):
        with RuleContext(self, UnlexerRule(name='TAG', parent=parent)) as current:
            UnlexerRule(src='<', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[0]), parent=current)
            UnlexerRule(src='>', parent=current)
            return current
    TAG.min_depth = 0

    def COMMENT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COMMENT', parent=parent)) as current:
            UnlexerRule(src='/*', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[0]), parent=current)
            UnlexerRule(src='*/', parent=current)
            return current
    COMMENT.min_depth = 0

    def LINE_COMMENT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LINE_COMMENT', parent=parent)) as current:
            UnlexerRule(src='//', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[0]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='\r', parent=current)
            UnlexerRule(src='\n', parent=current)
            return current
    LINE_COMMENT.min_depth = 0

    def PREPROC(self, parent=None):
        with RuleContext(self, UnlexerRule(name='PREPROC', parent=parent)) as current:
            UnlexerRule(src='#', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[5]), parent=current)
            return current
    PREPROC.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[6]), parent=current)
            return current
    WS.min_depth = 0

    _default_rule = graph

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(48, 58)])),
        2: list(itertools.chain.from_iterable([range(32, 34), range(35, 92), range(93, 127)])),
        3: list(itertools.chain.from_iterable([range(95, 96), range(97, 123)])),
        4: list(itertools.chain.from_iterable([range(32, 60), range(61, 62), range(63, 127)])),
        5: list(itertools.chain.from_iterable([range(32, 127)])),
        6: list(itertools.chain.from_iterable([range(9, 10), range(10, 11), range(13, 14), range(32, 33)])),
    }
