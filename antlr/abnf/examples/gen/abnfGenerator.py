# Generated by Grammarinator 23.7

import itertools

from math import inf
from grammarinator.runtime import *

class abnfGenerator(Generator):


    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    def rulelist(self, parent=None):
        with RuleContext(self, UnparserRule(name='rulelist', parent=parent)) as current:
            if self._max_depth >= 7:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    self.rule_(parent=current)
            self.EOF(parent=current)
            return current
    rulelist.min_depth = 1

    def rule_(self, parent=None):
        with RuleContext(self, UnparserRule(name='rule_', parent=parent)) as current:
            self.ID(parent=current)
            UnlexerRule(src='=', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    UnlexerRule(src='/', parent=current)
            self.elements(parent=current)
            return current
    rule_.min_depth = 6

    def elements(self, parent=None):
        with RuleContext(self, UnparserRule(name='elements', parent=parent)) as current:
            self.alternation(parent=current)
            return current
    elements.min_depth = 5

    def alternation(self, parent=None):
        with RuleContext(self, UnparserRule(name='alternation', parent=parent)) as current:
            self.concatenation(parent=current)
            if self._max_depth >= 4:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src='/', parent=current)
                    self.concatenation(parent=current)
            return current
    alternation.min_depth = 4

    def concatenation(self, parent=None):
        with RuleContext(self, UnparserRule(name='concatenation', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.repetition(parent=current)
            return current
    concatenation.min_depth = 3

    def repetition(self, parent=None):
        with RuleContext(self, UnparserRule(name='repetition', parent=parent)) as current:
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    self.repeat_(parent=current)
            self.element(parent=current)
            return current
    repetition.min_depth = 2

    def repeat_(self, parent=None):
        with RuleContext(self, UnparserRule(name='repeat_', parent=parent)) as current:
            with AlternationContext(self, [1, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    self.INT(parent=current)
                elif choice0 == 1:
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 0, min=0, max=1):
                            self.INT(parent=current)
                    UnlexerRule(src='*', parent=current)
                    if self._max_depth >= 1:
                        for _ in self._model.quantify(current, 1, min=0, max=1):
                            self.INT(parent=current)
            return current
    repeat_.min_depth = 0

    def element(self, parent=None):
        with RuleContext(self, UnparserRule(name='element', parent=parent)) as current:
            with AlternationContext(self, [2, 6, 6, 1, 3, 1], [1, 1, 1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.ID, self.group, self.option, self.STRING, self.NumberValue, self.ProseValue][choice0](parent=current)
            return current
    element.min_depth = 1

    def group(self, parent=None):
        with RuleContext(self, UnparserRule(name='group', parent=parent)) as current:
            UnlexerRule(src='(', parent=current)
            self.alternation(parent=current)
            UnlexerRule(src=')', parent=current)
            return current
    group.min_depth = 5

    def option(self, parent=None):
        with RuleContext(self, UnparserRule(name='option', parent=parent)) as current:
            UnlexerRule(src='[', parent=current)
            self.alternation(parent=current)
            UnlexerRule(src=']', parent=current)
            return current
    option.min_depth = 5

    def NumberValue(self, parent=None):
        with RuleContext(self, UnlexerRule(name='NumberValue', parent=parent)) as current:
            UnlexerRule(src='%', parent=current)
            with AlternationContext(self, [2, 2, 2], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                [self.BinaryValue, self.DecimalValue, self.HexValue][choice0](parent=current)
            return current
    NumberValue.min_depth = 2

    def BinaryValue(self, parent=None):
        with RuleContext(self, UnlexerRule(name='BinaryValue', parent=parent)) as current:
            UnlexerRule(src='b', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.BIT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            if self._max_depth >= 0:
                                for _ in self._model.quantify(current, 2, min=1, max=inf):
                                    UnlexerRule(src='.', parent=current)
                                    if self._max_depth >= 0:
                                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                                            self.BIT(parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src='-', parent=current)
                            if self._max_depth >= 0:
                                for _ in self._model.quantify(current, 4, min=1, max=inf):
                                    self.BIT(parent=current)
            return current
    BinaryValue.min_depth = 1

    def DecimalValue(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DecimalValue', parent=parent)) as current:
            UnlexerRule(src='d', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.DIGIT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            if self._max_depth >= 0:
                                for _ in self._model.quantify(current, 2, min=1, max=inf):
                                    UnlexerRule(src='.', parent=current)
                                    if self._max_depth >= 0:
                                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                                            self.DIGIT(parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src='-', parent=current)
                            if self._max_depth >= 0:
                                for _ in self._model.quantify(current, 4, min=1, max=inf):
                                    self.DIGIT(parent=current)
            return current
    DecimalValue.min_depth = 1

    def HexValue(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HexValue', parent=parent)) as current:
            UnlexerRule(src='x', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    self.HEX_DIGIT(parent=current)
            if self._max_depth >= 1:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    with AlternationContext(self, [1, 1], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        if choice0 == 0:
                            if self._max_depth >= 0:
                                for _ in self._model.quantify(current, 2, min=1, max=inf):
                                    UnlexerRule(src='.', parent=current)
                                    if self._max_depth >= 0:
                                        for _ in self._model.quantify(current, 3, min=1, max=inf):
                                            self.HEX_DIGIT(parent=current)
                        elif choice0 == 1:
                            UnlexerRule(src='-', parent=current)
                            if self._max_depth >= 0:
                                for _ in self._model.quantify(current, 4, min=1, max=inf):
                                    self.HEX_DIGIT(parent=current)
            return current
    HexValue.min_depth = 1

    def ProseValue(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ProseValue', parent=parent)) as current:
            UnlexerRule(src='<', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[1]), parent=current)
            UnlexerRule(src='>', parent=current)
            return current
    ProseValue.min_depth = 0

    def ID(self, parent=None):
        with RuleContext(self, UnlexerRule(name='ID', parent=parent)) as current:
            self.LETTER(parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    with AlternationContext(self, [1, 1, 0], [1, 1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        src = [None, None, '-'][choice0]
                        rule = [self.LETTER, self.DIGIT, None][choice0]
                        if src is not None:
                            UnlexerRule(src=src, parent=current)
                        else:
                            rule(parent=current)
            return current
    ID.min_depth = 1

    def INT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='INT', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=1, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[2]), parent=current)
            return current
    INT.min_depth = 0

    def COMMENT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='COMMENT', parent=parent)) as current:
            UnlexerRule(src=';', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[3]), parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=1):
                    UnlexerRule(src='\r', parent=current)
            UnlexerRule(src='\n', parent=current)
            return current
    COMMENT.min_depth = 0

    def WS(self, parent=None):
        with RuleContext(self, UnlexerRule(name='WS', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0, 0], [1, 1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                UnlexerRule(src=[' ', '\t', '\r', '\n'][choice0], parent=current)
            return current
    WS.min_depth = 0

    def STRING(self, parent=None):
        with RuleContext(self, UnlexerRule(name='STRING', parent=parent)) as current:
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 0, min=0, max=1):
                    with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                        choice0 = self._model.choice(current, 0, weights0)
                        UnlexerRule(src=['%s', '%i'][choice0], parent=current)
            UnlexerRule(src='"', parent=current)
            if self._max_depth >= 0:
                for _ in self._model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[4]), parent=current)
            UnlexerRule(src='"', parent=current)
            return current
    STRING.min_depth = 0

    def LETTER(self, parent=None):
        with RuleContext(self, UnlexerRule(name='LETTER', parent=parent)) as current:
            with AlternationContext(self, [0, 0], [1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[5]), parent=current)
                elif choice0 == 1:
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[6]), parent=current)
            return current
    LETTER.min_depth = 0

    def BIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='BIT', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[7]), parent=current)
            return current
    BIT.min_depth = 0

    def DIGIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='DIGIT', parent=parent)) as current:
            UnlexerRule(src=self._model.charset(current, 0, self._charsets[8]), parent=current)
            return current
    DIGIT.min_depth = 0

    def HEX_DIGIT(self, parent=None):
        with RuleContext(self, UnlexerRule(name='HEX_DIGIT', parent=parent)) as current:
            with AlternationContext(self, [0, 0, 0], [1, 1, 1]) as weights0:
                choice0 = self._model.choice(current, 0, weights0)
                if choice0 == 0:
                    UnlexerRule(src=self._model.charset(current, 0, self._charsets[9]), parent=current)
                elif choice0 == 1:
                    UnlexerRule(src=self._model.charset(current, 1, self._charsets[10]), parent=current)
                elif choice0 == 2:
                    UnlexerRule(src=self._model.charset(current, 2, self._charsets[11]), parent=current)
            return current
    HEX_DIGIT.min_depth = 0

    _default_rule = rulelist

    _charsets = {
        0: list(itertools.chain.from_iterable([range(32, 127)])),
        1: list(itertools.chain.from_iterable([range(32, 62), range(63, 127)])),
        2: list(itertools.chain.from_iterable([range(48, 58)])),
        3: list(itertools.chain.from_iterable([range(32, 127)])),
        4: list(itertools.chain.from_iterable([range(32, 34), range(35, 127)])),
        5: list(itertools.chain.from_iterable([range(97, 123)])),
        6: list(itertools.chain.from_iterable([range(65, 91)])),
        7: list(itertools.chain.from_iterable([range(48, 50)])),
        8: list(itertools.chain.from_iterable([range(48, 58)])),
        9: list(itertools.chain.from_iterable([range(48, 58)])),
        10: list(itertools.chain.from_iterable([range(97, 103)])),
        11: list(itertools.chain.from_iterable([range(65, 71)])),
    }
